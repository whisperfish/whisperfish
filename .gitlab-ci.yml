variables: &variables
  SFOS_VERSION: 5.0.0.43
  GIT_FETCH_EXTRA_FLAGS: --tags
  RUST_BACKTRACE: full
  # Output dir for the webrtc artifacts
  OUTPUT_DIR: $CI_PROJECT_DIR/ringrtc/322/x86_64-unknown-linux-gnu/

include:
  # Awesome OpenRepos script by @nobodyinperson/Yann BÃ¼chau
  - https://gitlab.com/nobodyinperson/python3-openrepos-webclient/-/raw/master/openrepos-upload-rpm.gitlab-ci.yml
  # The MergeRequest-Pipelines template makes your pipelines run for the default branch, tags, and all types of merge request pipelines.
  - template: "Workflows/MergeRequest-Pipelines.gitlab-ci.yml"
  - project: "dependabot-gitlab/dependabot-standalone"
    file: ".gitlab-ci.yml"

stages:
  - prep
  - build
  - test
  - format
  - deploy

.rust: &rust
  image: rust
  cache: &rust-cache
    paths:
      - target/
      - /usr/local/cargo/bin/
      - /usr/local/cargo/registry/index/
      - /usr/local/cargo/registry/cache/
      - /usr/local/cargo/git/db/
  before_script:
    - apt-get update
    - apt-get install -y --no-install-recommends libsqlcipher-dev qtbase5-dev qtbase5-private-dev qt5-qmake cmake qtdeclarative5-dev qtbase5-dev-tools qttools5-dev-tools protobuf-compiler libdbus-1-dev libqt5opengl5-dev libssl-dev libgstreamer1.0-dev
    - cargo --version
    - rustc --version

.build-sailfishos: &build-sailfishos
  image: registry.gitlab.com/whisperfish/sailo-rs/rust-$MER_ARCH-$SFOS_VERSION:latest
  stage: build
  needs:
    - prep:host:vendor-tar-gz:stable
  variables:
    - CARGO_HOME: cargo
  cache: &sfos-cache
    paths:
      - ringrtc/
      - target/
      - cargo/bin/
      - cargo/registry/index/
      - cargo/registry/cache/
      - cargo/git/db/
  artifacts:
    paths:
      - RPMS/*.rpm
      - target/*/release/whisperfish-migration-dry-run
      - target/*/release/fetch-signal-attachment
      - target/*/release/harbour-whisperfish

build:sf:latest:armv7hl:
  extends: .build-sailfishos
  variables:
    <<: *variables
    MER_ARCH: armv7hl
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
      when: never
    - when: on_success
  cache:
    <<: *sfos-cache
    key: target-armv7hl
  script:
    - ./fetch-webrtc.sh armv7hl
    - .ci/unpack-vendor.sh
    - .ci/build-with-mb2.sh

build:sf:latest:i486:
  extends: .build-sailfishos
  variables:
    <<: *variables
    MER_ARCH: i486
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
      when: never
    - when: on_success
  cache:
    <<: *sfos-cache
    key: target-i486
  script:
    - ./fetch-webrtc.sh i486
    - .ci/unpack-vendor.sh
    - .ci/build-with-mb2.sh

build:sf:latest:aarch64:
  extends: .build-sailfishos
  variables:
    <<: *variables
    MER_ARCH: aarch64
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
      when: never
    - when: on_success
  cache:
    <<: *sfos-cache
    key: target-aarch64
  script:
    - ./fetch-webrtc.sh aarch64
    - .ci/unpack-vendor.sh
    - .ci/build-with-mb2.sh

build:host:stable:
  <<: *rust
  stage: build
  needs:
    - job: prep:host:vendor-tar-gz:stable
  script:
    - .ci/unpack-vendor.sh
    - cargo build --offline --features bundled-sqlcipher
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
      when: never
    - when: on_success
  cache:
    - key: rust-stable
      <<: *rust-cache

prep:host:vendor-tar-gz:stable:
  image: rust
  cache:
    - key: vendor-target
      paths:
        - /usr/local/cargo/bin/
        - /usr/local/cargo/registry/index/
        - /usr/local/cargo/registry/cache/
        - /usr/local/cargo/git/db/
    - key: vendor-tar
      policy: pull-push
      paths:
        - vendor.tar.xz
        - vendor.toml
  stage: prep
  before_script:
    - cargo --version
    - rustc --version
  script:
    - .ci/unpack-vendor.sh || true
    - cargo vendor | tee vendor.toml # --> .cargo/config.toml
    - tar -cO vendor/ | xz -z -T4 > vendor.tar.xz
  artifacts:
    paths:
      - vendor.tar.xz
      - vendor.toml
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
      when: never
    - when: on_success

build:host:nightly:
  <<: *rust
  image: rustlang/rust:nightly-bookworm
  stage: build
  allow_failure: true
  needs:
    # Run only if stable already succeeded. We don't use the results of this
    # job and run it only to test future versions of rust. See the discussion
    # in https://gitlab.com/whisperfish/whisperfish/-/merge_requests/202
    - job: build:host:stable
      artifacts: false
    - job: prep:host:vendor-tar-gz:stable
  script:
    - .ci/unpack-vendor.sh
    - cargo build --offline --features bundled-sqlcipher
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
      when: never
    - when: on_success
  cache:
    - key: rust-nightly
      <<: *rust-cache

build:host:stable:docs:
  <<: *rust
  stage: build
  needs:
    - job: build:host:stable
      artifacts: false
    - job: prep:host:vendor-tar-gz:stable
  script:
    - .ci/unpack-vendor.sh
    - cargo doc --no-deps --document-private-items -p harbour-whisperfish -p libsignal-service -p libsignal-protocol -p zkgroup -p whisperfish
  artifacts:
    paths:
      - target/doc
  # This job has no large overhead. Thus, we fetch only the cache from the
  # build job and don't interfere with later tests jobs.
  cache:
    <<: *rust-cache
    key: rust-stable
    policy: pull
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
      when: never
    - when: on_success

build:host:stable:tarball:
  <<: *rust
  stage: build
  needs:
    - build:host:stable
  before_script:
    - export P="${CI_PROJECT_NAME}-${CI_COMMIT_TAG#v}"
  script:
    - git archive --prefix="${P}/" -o ${P}.tar ${CI_COMMIT_TAG}
    - .ci/unpack-vendor.sh
    - pushd ${P}
    - mkdir -p .cargo
    - mv ../vendor ./vendor
    - mv ../vendor.toml .cargo/config.toml
    - cargo vendor
    - popd
    - tar --append -f ${P}.tar ${P}
    - gzip ${P}.tar
  after_script:
    - echo TGZ_JOB_ID=${CI_JOB_ID} >> build.env
    - echo PACKAGE_NAME="${CI_PROJECT_NAME}-${CI_COMMIT_TAG#v}" >> build.env
  artifacts:
    paths:
      - ./*.tar.gz
    reports:
      dotenv: build.env
  cache:
    <<: *rust-cache
    key: rust-stable
    policy: pull
  only:
    - tags

qmllint:
  <<: *rust
  stage: format
  image: rust
  # Disable cache - qmllint doesn't need anything.
  cache: {}
  script:
    - "qmllint qml/**/*.qml"
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
      when: never
    - when: on_success

test:stable:
  <<: *rust
  stage: test
  needs:
    - job: build:host:stable
      artifacts: false
    - job: prep:host:vendor-tar-gz:stable
  script:
    - .ci/unpack-vendor.sh
    - cargo test --offline --features whisperfish/bundled-sqlcipher
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
      when: never
    - when: on_success
  cache:
    - key: rust-stable
      <<: *rust-cache
      policy: pull

test:cargo-deny:
  <<: *rust
  stage: test
  # XXX Cargo deny can use vendor.tar.xz
  needs: []
  script:
    - cargo install --locked cargo-deny
    - export PATH="$CARGO_HOME/bin:$PATH"
    - cargo deny check
  # XXX Separate rust-stable cargo/ and target/ caches
  cache: {}
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule" && $CI_SCHEDULE == "cargo-deny"
    - if: $CI_PIPELINE_SOURCE == "merge_request_event"
      allow_failure: true

test:stable:diesel-schema:
  <<: *rust
  stage: test
  # Cargo fmt doesn't need even vendored sources
  needs: []
  script:
    - rustup override set 1.89.0
    - rustup component add rustfmt
    # Diesel is not running a long time/often. We don't need the release
    # version here and the debug version is enough. We save a lot of
    # compilation time for small overhead when running the binary.
    - cargo install -f --debug diesel_cli --version "^2.2" --features "sqlite-bundled"
    - export PATH="$CARGO_HOME/bin:$PATH"
    - export DATABASE_URL=test_whisperfish.db
    # Diesel does not need to access build artifacts of other stages.
    - diesel setup
    - diesel migration run
    - diesel print-schema > whisperfish-store/src/schema.rs
    - diesel print-schema --schema-key protocol > whisperfish-store/src/schema/protocol.rs
    # Cargo fmt doesn't need vendored sources
    - cargo fmt -- --check whisperfish-store/src/schema.rs
    - cargo fmt -- --check whisperfish-store/src/schema/protocol.rs
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
      when: never
    - when: on_success

fmt:stable:
  <<: *rust
  stage: format
  needs: []
  # Cargo fmt does not need external packages.
  before_script: []
  script:
    - rustup component add rustfmt
    # Cargo fmt does not need external packages.
    - cargo fmt -- --check
    # Cargo fmt does not need to access the cache. With it's own cache, it does
    # not interfere with `coverage:stable` and `clippy:stable`. There is nothing
  # to store in the cache either.
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
      when: never
    - when: on_success

coverage:stable:
  <<: *rust
  image: rust
  # ASLR disable failed: EPERM: Operation not permitted
  allow_failure: true
  stage: format
  needs:
    - job: prep:host:vendor-tar-gz:stable
    # Make sure the project compiles before attempting llvm-cov.
    - job: build:host:stable
      artifacts: false
  variables:
    <<: *variables
    QT_SELECT: qt5
  script:
    - .ci/unpack-vendor.sh
    - rustup component add llvm-tools-preview
    # We don't need an optimized llvm-cov, we only run it once per pipeline.
    - cargo install -f --debug cargo-llvm-cov
    - export PATH="$CARGO_HOME/bin:$PATH"
    # Add --all-features and --all-targets some time in the future. Tarpaulin
    # runs only at linux-x86 and would need the whisperfish sdk to build all
    # features.
    - cargo llvm-cov --all --features bundled-sqlcipher --no-fail-fast || true
    - cargo llvm-cov report --cobertura --output-path cobertura.xml
    - cargo llvm-cov report --html
  artifacts:
    name: ${CI_JOB_NAME}-${CI_COMMIT_REF_NAME}-${CI_COMMIT_SHA}
    reports:
      coverage_report:
        coverage_format: cobertura
        path: cobertura.xml
    paths:
      - target/llvm-cov/html
  coverage: '/TOTAL\s+(\d+\s+)+(\d+\.\d+\%)/'
  # Tarpaulin needs its own cache as many more information are stored from
  # other crates. In addition, `clippy:stable` can pull/push the cache from
  # `test:stable` and the tarpaulin job does not interfere with the clippy
  # cache.
  cache:
    <<: *rust-cache
    key: rust-nightly-llvm-cov
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
      when: never
    - when: on_success

clippy:stable:
  <<: *rust
  stage: format
  needs:
    - prep:host:vendor-tar-gz:stable
  script:
    - .ci/unpack-vendor.sh
    - rustup override set 1.89.0
    - rustup component add clippy
    # the following command should be used but needs sailfish SDK
    # - cargo clippy --offline --all-targets --all-features
    #
    # Two allows are put in globally, because they occur from macro invocations.
    # derive_partial_eq_without_eq occurs by prost, and prost suggests to disable the lint globally:
    #   https://github.com/tokio-rs/prost/issues/661
    # useless-transmute
    - cargo clippy --offline --all-targets -- -A clippy::derive_partial_eq_without_eq -A clippy::useless_transmute
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
      when: never
    - when: on_success
  cache:
    <<: *rust-cache
    key: rust-stable-clippy

clippy:stable-warnings:
  <<: *rust
  stage: format
  allow_failure: true
  needs:
    - prep:host:vendor-tar-gz:stable
  script:
    - .ci/unpack-vendor.sh
    - rustup component add clippy
    # the following command should be used but needs sailfish SDK
    # - cargo clippy --offline --all-targets --all-features -- -D warnings
    #
    # For allows, see above
    - cargo clippy --offline --all-targets -- -D warnings -A clippy::derive_partial_eq_without_eq -A clippy::useless_transmute
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
      when: never
    - when: on_success
  cache:
    <<: *rust-cache
    key: rust-stable-clippy
    policy: pull

.translations: &translations
  image: debian
  needs: []
  before_script:
    - apt-get update
    - apt-get install --no-install-recommends -y git curl qtbase5-dev qtchooser qt5-qmake qtbase5-dev-tools qttools5-dev-tools ca-certificates

translations:check:
  <<: *translations
  stage: test
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
      when: never
    - if: "$CI_COMMIT_BRANCH != $CI_DEFAULT_BRANCH"
  script:
    - .ci/check-translations.sh

translations:update:
  <<: *translations
  stage: deploy
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
      when: never
    - if: "$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH"
  variables:
    # Clone with full depth for translation contribution analysis
    GIT_STRATEGY: clone
    GIT_DEPTH: 0
  script:
    - .ci/update-translation-contributors.sh
    - .ci/update-translations.sh

test:sailfishos:validate-rpms:
  stage: test
  image: registry.gitlab.com/whisperfish/sailo-rs/rpm-validator:latest
  allow_failure: true
  needs:
    - build:sf:latest:i486
    - build:sf:latest:armv7hl
    - build:sf:latest:aarch64
  script:
    # Only the main rpm needs to be validation
    - rm -f RPMS/*debuginfo* RPMS/*debugsource*
    - for rpm in RPMS/*.rpm; do rpmvalidation.sh $rpm; done
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
      when: never
    - when: on_success

notify_matrix_build_ready:
  stage: deploy
  image: debian
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
      when: never
    - if: "$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH"
  environment:
    name: Whisperfish Matrix channel
    url: $MATRIX_HOME_SERVER
  needs:
    - job: build:sf:latest:armv7hl
      artifacts: false
    - job: build:sf:latest:aarch64
      artifacts: false
    - job: build:sf:latest:i486
      artifacts: false
  before_script:
    - apt-get update
    - apt-get install --no-install-recommends -y git curl jq ca-certificates
  script:
    # Build notification only needs the git repo
    - .ci/send-matrix-build-notification.sh

pages:
  needs:
    - build:host:stable:docs
  stage: deploy
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule"
      when: never
    - if: "$CI_COMMIT_BRANCH == $CI_DEFAULT_BRANCH"
  script:
    - mkdir -p public
    - mv target/doc public/
  artifacts:
    paths:
      - public

.deploy:openrepos: &deploy-openrepos
  stage: deploy
  extends: .openrepos-upload-rpm
  variables: &openrepos-vars
    OPENREPOS_WEBCLIENT_INSTALL_SOURCE: "git+https://gitlab.com/nobodyinperson/python3-openrepos-webclient"
    OPENREPOS_UPLOAD_RPM_PLATFORM: SailfishOS
    OPENREPOS_UPLOAD_RPM_CATEGORY: Applications
  only:
    - tags
  before_script:
    - mv RPMS/*.rpm .

deploy:openrepos:whisperfish:
  <<: *deploy-openrepos
  variables:
    <<: *openrepos-vars
    OPENREPOS_UPLOAD_RPM_APPNAME: Whisperfish
  environment:
    name: OpenRepos
    url: https://openrepos.net/content/rubdos/whisperfish
  needs:
    - build:sf:latest:armv7hl
    - build:sf:latest:i486
    - build:sf:latest:aarch64
    - test:stable

deploy:gitlab:tarball:
  stage: deploy
  image: registry.gitlab.com/gitlab-org/release-cli:latest
  needs:
    - job: build:host:stable:tarball
  script:
    - echo "Running release job"
  release:
    name: Release ${CI_COMMIT_TAG}
    description: Created using the release-cli
    tag_name: ${CI_COMMIT_TAG}
    ref: ${CI_COMMIT_TAG}
    assets:
      links:
        - name: ${PACKAGE_NAME}.tar.gz
          url: ${CI_PROJECT_URL}/-/jobs/${TGZ_JOB_ID}/artifacts/raw/${PACKAGE_NAME}.tar.gz
  only:
    - tags

deploy:chum:
  stage: deploy
  image: opensuse/leap
  only:
    - tags
  environment:
    name: "OBS Chum"
    url: "https://build.sailfishos.org/package/show/home:rubdos:whisperfish/Whisperfish"
  needs:
    - prep:host:vendor-tar-gz:stable
  script:
    - echo $OSCRC | base64 -d > ~/.oscrc
    - zypper install -y osc
    - sed -i.bak "s/main//" _service
    - sed -i.bak "s/revision\">/revision\">$CI_COMMIT_TAG/" _service
    - cat _service
    - osc ls home:rubdos:whisperfish Whisperfish
    - osc co home:rubdos:whisperfish Whisperfish
    - cp vendor.tar.xz _service vendor.toml home:rubdos:whisperfish/Whisperfish/
    - cd home:rubdos:whisperfish/Whisperfish
    - osc ci -m "Resources for Whisperfish $CI_COMMIT_TAG"
    # osc submitrequest sailfishos:chum:testing

dry-run:triage:
  stage: test
  image: ruby:2.4
  script:
    - gem install gitlab-triage
    - gitlab-triage --help
    - gitlab-triage --dry-run --token $PRIVATE_TOKEN --source projects --source-id $CI_PROJECT_PATH
  when: manual

policy:run:
  stage: deploy
  image: ruby:2.4
  script:
    - gem install gitlab-triage
    - gitlab-triage --token $PRIVATE_TOKEN --source projects --source-id $CI_PROJECT_PATH
  when: manual

.schedule:policyrun:
  stage: deploy
  image: ruby:2.4
  script:
    - gem install gitlab-triage
    - gitlab-triage --token $PRIVATE_TOKEN --source projects --source-id $CI_PROJECT_PATH
  rules:
    - if: $CI_PIPELINE_SOURCE == "schedule" && $CI_SCHEDULE == "policy"

.dependabot-gitlab:
  stage: deploy
